# 16进制注释格式说明

版本：1.0

## 概述

CalcPaper 在处理包含位运算或16进制/2进制数值的表达式时，会自动在注释中以16进制格式显示变量值，使位运算过程更加清晰易懂。

## 自动16进制注释

### 触发条件

当表达式满足以下任一条件时，变量值会以16进制格式显示在注释中：

1. 表达式包含16进制数值（0x...）
2. 表达式包含2进制数值（0b...）
3. 表达式包含位运算符（<<、>>、&、|、^、~）

### 示例

#### 示例1：包含16进制数值

```python
# 输入
a = 0xFF
b = 0x10
和 = a + b
```

```python
# 输出
a = 0xFF        = 255
b = 0x10        = 16
和 = a + b      = 271  # 0xFF + 0x10
```

#### 示例2：包含位运算

```python
# 输入
x = 255
y = 15
与运算 = x & y
```

```python
# 输出
x = 255              = 255
y = 15               = 15
与运算 = x & y       = 15  # 0xFF & 0xF
```

#### 示例3：混合运算

```python
# 输入
颜色 = 0xFF8040
红色 = (颜色 >> 16) & 0xFF
绿色 = (颜色 >> 8) & 0xFF
蓝色 = 颜色 & 0xFF
```

```python
# 输出
颜色 = 0xFF8040                    = 16744512
红色 = (颜色 >> 16) & 0xFF         = 255  # 0xFF8040 >> 16 & 0xFF
绿色 = (颜色 >> 8) & 0xFF          = 128  # 0xFF8040 >> 8 & 0xFF
蓝色 = 颜色 & 0xFF                 = 64   # 0xFF8040 & 0xFF
```

## 注释格式规则

### 1. 变量替换

当表达式中引用了变量时，注释会显示替换后的完整表达式：

```python
# 输入
a = 0xFF
b = 0x0F
结果 = a & b
```

```python
# 输出
a = 0xFF        = 255
b = 0x0F        = 15
结果 = a & b    = 15  # 0xFF & 0xF
```

### 2. 16进制格式

- 正整数：使用大写16进制格式（0xFF）
- 负整数：使用十进制格式
- 浮点数：使用十进制格式

```python
# 输入
正数 = 255
负数 = -10
小数 = 3.14
位运算 = 正数 >> 4
```

```python
# 输出
正数 = 255           = 255
负数 = -10           = -10
小数 = 3.14          = 3.14
位运算 = 正数 >> 4   = 15  # 0xFF >> 4
```

### 3. 复杂表达式

对于复杂表达式，注释会完整显示所有变量替换后的结果：

```python
# 输入
a = 0xFF
b = 0x0F
c = 0xF0
复杂 = (a & b) | (a & c)
```

```python
# 输出
a = 0xFF                    = 255
b = 0x0F                    = 15
c = 0xF0                    = 240
复杂 = (a & b) | (a & c)    = 255  # (0xFF & 0xF) | (0xFF & 0xF0)
```

## 不显示16进制注释的情况

### 1. 纯算术运算

不包含16进制、2进制或位运算的表达式，不会显示16进制注释：

```python
# 输入
a = 100
b = 200
和 = a + b
```

```python
# 输出
a = 100        = 100
b = 200        = 200
和 = a + b     = 300  # 100 + 200（十进制）
```

### 2. 百分数计算

```python
# 输入
价格 = 100
折扣 = 15%
实付 = 价格 * (1 - 折扣)
```

```python
# 输出
价格 = 100                    = 100
折扣 = 15%                    = 0.15
实付 = 价格 * (1 - 折扣)      = 85.00  # 100 * (1 - 0.15)
```

## 与 bitmap 关键字的区别

### 16进制注释

- 自动触发
- 显示在行尾注释中
- 只显示替换后的表达式
- 不显示位结构

```python
a = 0xFF
b = a & 0x0F  # 自动显示：0xFF & 0xF
```

### bitmap 关键字

- 需要显式使用
- 显示在独立的多行输出中
- 显示详细的位结构信息
- 包含16进制、2进制和位索引

```python
endian: big
bitmap 查看 = 0xFF
# 输出：
# 十六进制: 0xFF
# 二进制: 0b11111111
# 位数: 8 bits (1 bytes)
# 位索引表格...
```

## 实用场景

### 场景1：调试位运算

```python
# 输入
掩码 = 0xFF00
数据 = 0xABCD
提取高字节 = 数据 & 掩码
```

```python
# 输出
掩码 = 0xFF00                = 65280
数据 = 0xABCD                = 43981
提取高字节 = 数据 & 掩码     = 43776  # 0xABCD & 0xFF00
```

通过注释可以清楚看到：0xABCD & 0xFF00 = 0xAB00 (43776)

### 场景2：RGB颜色计算

```python
# 输入
R = 0xFF
G = 0x80
B = 0x40
颜色 = (R << 16) | (G << 8) | B
```

```python
# 输出
R = 0xFF                        = 255
G = 0x80                        = 128
B = 0x40                        = 64
颜色 = (R << 16) | (G << 8) | B = 16744512  # (0xFF << 16) | (0x80 << 8) | 0x40
```

### 场景3：网络协议解析

```python
# 输入
数据包 = 0x12345678
类型 = (数据包 >> 24) & 0xFF
版本 = (数据包 >> 16) & 0xFF
长度 = (数据包 >> 8) & 0xFF
标志 = 数据包 & 0xFF
```

```python
# 输出
数据包 = 0x12345678                = 305419896
类型 = (数据包 >> 24) & 0xFF       = 18   # 0x12345678 >> 24 & 0xFF
版本 = (数据包 >> 16) & 0xFF       = 52   # 0x12345678 >> 16 & 0xFF
长度 = (数据包 >> 8) & 0xFF        = 86   # 0x12345678 >> 8 & 0xFF
标志 = 数据包 & 0xFF               = 120  # 0x12345678 & 0xFF
```

## 配置选项

目前16进制注释格式是自动的，无需配置。未来版本可能会添加以下选项：

- 强制所有变量使用16进制格式
- 自定义16进制格式（大写/小写）
- 控制注释显示的详细程度

## 最佳实践

1. **使用16进制字面量**：当处理位运算时，使用16进制字面量（0xFF）而不是十进制（255），这样注释更清晰

2. **合理命名变量**：使用有意义的变量名，配合16进制注释，使代码更易读

3. **分步骤计算**：复杂的位运算分成多个步骤，每步都有清晰的注释

4. **结合 bitmap**：对于需要详细查看位结构的情况，使用 bitmap 关键字

## 相关文档

- [使用指南](使用指南.md)
- [位运算快速参考](位运算快速参考.md)
- [bitmap关键字说明](bitmap关键字说明.md)
